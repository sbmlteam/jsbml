\section{Introduction}

The intention of implementing a pure Java\texttrademark{}
Application Programming Interface (API) for working with SBML files was not to
re-implement the existing Java API of libSBML
\index{application programming interface!libSBML}%
\citep{Bornstein2008}.
From the very beginning, JSBML
\index{application programming interface!JSBML}%
has been designed based on the SBML specifications \citep{Hucka2003, Hucka2008,
Hucka2010a} but with respect to naming conventions of methods and variables from
libSBML. Similarly to the SBML specifications,
\index{SBML!specification}%
the libSBML library has grown historically. The implementation of JSBML
permitted to entirely re-design the type hierarchy of the SBML elements and the
way to implement what is specified in the SBML documents. However, it is
important to keep in mind that SBML is a language that defines how to store of
biological processes and how to exchange these models between
\index{model!storage and exchange}%
different software tools. It
does not specify how to represent its elements in memory. Furthermore, during
the evolution of SBML some elements or properties of elements have become
obsolete.
\index{deprecation}%
It is therefore up to an implementing library to
decide how to deal with those constructs. To facilitate switching from libSBML
to JSBML and the other way around, JSBML has been designed to behave similarly
to libSBML but, due to the different background of both libraries and the fact
that libSBML is based on \texttt{C}
\index{C@\texttt{C}}%
and \texttt{C++}
\index{C++@\texttt{C++}}%
code, some differences are unavoidable. In cases of doubt JSBML tries to mirror
the SBML specifications rather than libSBML. Finally, JSBML has also been
developed as a library that does not ``only" provide reading, manipulating, and
writing abilities for SBML files. It is intended to be directly used as a
flexible internal data structure for numerical computation, visualization and
much more. With the help of its modules JSBML can also be used as a
communication layer between applications. For instance, JSBML facilitates the
implementation of plugins for the program know as CellDesigner
\citep{Funahashi2003}. The following sections will not only give a detailed
overview about the most important differences between JSBML and libSBML, but
also provide some programming examples and hints about how to use and work with
JSBML.


\section{An extended type hierarchy}

\begin{sidewaysfigure}[htbp]
\centering
\includegraphics[width=\textwidth]{../img/FullTypeHierarchy.pdf}
\caption[The type hierarchy of the main SBML constructs in JSBML]{The type
hierarchy of the main SBML constructs in JSBML. With letting \texttt{SBase}
extend the interface \texttt{TreeNodeWithChangeSupport} that in turn extends the
Java interfaces \texttt{Cloneable}, \texttt{Serializable}, and
\texttt{TreeNode}, all derived elements of \texttt{SBase} also implement these
types. In this way, derivatives of \texttt{SBase} can be used wherever an
instance of \texttt{TreeNode} is requested. Furthermore, SBML elements that do
not extend \texttt{SBase} are also derived from the identical base type
\texttt{TreeNodeWithChangeSupport}, hence sharing several common methods and
attributes. Elements colored in blue have been introduced as additional, in most
cases abstract, data types in JSBML but do not have a corresponding element in
libSBML. The yellow types \texttt{Creator} and \texttt{History} correspond to
\texttt{ModelCreator} and \texttt{ModelHistory} in libSBML.}
\label{fig:TypeHierarchy}
\end{sidewaysfigure}
\begin{figure}[p]
 \centering
 \includegraphics[width=\textwidth]{img/SBase.pdf}
 % SBase.pdf: 1001x568 pixel, 72dpi, 35.31x20.04 cm, bb=0 0 1001 568
 \caption[The interface \texttt{SBase}]{The interface \texttt{SBase}. 
This figure displays the most important top-level data
structures of JSBML with main focus on the differences to libSBML. All data
types that represent SBML constructs in JSBML extend \texttt{AbstractTreeNode}. 
Derivatives of \texttt{SBase} extend either one of the two abstract classes
\texttt{AbstractSBase} or \texttt{AbstractNamedSBase}, which in turn also extend
\texttt{AbstractTreeNode}. The class \texttt{SBO} parses the
ontology\index{Ontology} file provided on the SBO web site
(\url{http://www.ebi.ac.uk/sbo/main/}) in OBO format (Open Biomedical
Ontologies) using a parser provided by the BioJava project \citep{Holland2008}.
For the sake of a clear arrangement, this figure omits all methods in the UML
diagram. \texttt{SBO} stores its ontology in the classes \texttt{Term} that are
interrelated in \texttt{Triples} consisting of subject, predicate, and object
(each being an instance of \texttt{Term}).}
 \label{fig:SBase}
\end{figure}
\begin{figure}[p]
 \centering
 \includegraphics[width=\textwidth]{img/Symbol.pdf}
 % Symbol.pdf: 596x587 pixel, 72dpi, 21.03x20.71 cm, bb=0 0 596 587
 \caption[The interface \texttt{Variable}]{The interface \texttt{Variable}.
 JSBML refers to those components of a model that may change their value during
 a simulation as \texttt{Variable}s. The class \texttt{Symbol} serves as the
 abstract superclass for variables that can also be equipped with a unit.
 Instances of \texttt{Parameter} do not contain any additional field. In
 \texttt{Species}, a Boolean switch decides whether its value is to be
 interpreted as an initial amount or as an initial concentration. In contrast
 to \texttt{Variable}s, \texttt{LocalParameter}s represent constant unit-value
 pairs that can only be accessed within their declaring
 \texttt{KineticLaw}.}
 \label{fig:Variable}
\end{figure}
\begin{figure}[p]
 \centering
 \includegraphics[width=\textwidth]{img/ASTNode.pdf}
 % MathContainerClass.pdf: 557x396 pixel, 72dpi, 19.65x13.97 cm, bb=0 0 557 396
 \caption[Abstract syntax trees]{Abstract syntax trees. The class
 \texttt{AbstractMathContainer} serves as the superclass for several model
 components in JSBML. It provides methods to manipulate and access an instance 
 of \texttt{ASTNode}, which can be converted to or read from \texttt{C}-like
 formula \texttt{String}s. Internally, \texttt{AbstractMathContainer}s only
 deal with instances of \texttt{ASTNode}. It should be noted that these
 abstract syntax trees do not implement the \texttt{SBase} interface, but
 extend \texttt{AbstractTreeNode}.}
 \label{fig:MathContainer}
\end{figure}
\begin{sidewaysfigure}[htbp]
 \centering
 \includegraphics[width=\textwidth]{img/MathContainer.pdf}
 % MathContainerClass.pdf: 557x396 pixel, 72dpi, 19.65x13.97 cm, bb=0 0 557 396
 \caption[Containers for mathematical expressions]{Containers for mathematical
 expressions. The interface \texttt{MathContainer}, particularly
 its directly derived class \texttt{AbstractMathContainer}, constitutes the
 superclass for all elements that store and manipulate mathematical formulas in
 JSBML, which is done in form of \texttt{ASTNode} objects. These can be
 evaluated using an implementation of \texttt{ASTNodeCompiler}. Note that some
 classes that extend \texttt{AbstractMathContainer} do not contain any own
 fields or methods: \texttt{Delay}, \texttt{Priority},
 \texttt{StoichiometryMath}, or \texttt{AlgebraicRule}.}
 \label{fig:MathContainerHierarchy}
\end{sidewaysfigure}
Whenever multiple elements defined in at least one of the SBML
\index{SBML}%
specifications
\index{SBML!specification}%
share some attributes, JSBML
\index{JSBML!type hierarchy}%
provides a common superclass or at least a common interface that gathers methods
for the manipulation of the shared properties. In this way, the type hierarchy
of JSBML
\index{application programming interface!JSBML}%
has become quite complex (see
Figs.~\vrefrange{fig:TypeHierarchy}{fig:MathContainerHierarchy}). Just as in
libSBML,
\index{application programming interface!libSBML}%
all elements extend the abstract type \texttt{SBase},
\index{SBase@\texttt{SBase}}%
but in JSBML, \texttt{SBase} has become an interface. This allows more complex
relations between derived data types. In contrast to libSBML, \texttt{SBase} in
JSBML extends the interface \texttt{TreeNodeWithChangeSupport}%
\index{TreeNodeWithChangeSupport@\texttt{TreeNodeWithChangeSupport}} 
that in turn extends three other interfaces: \texttt{Cloneable},
\texttt{Serializable}, \index{Serializable@\texttt{Serializable}}% and \texttt{TreeNode}. As all elements defined in JSBML
\index{cloning}%
override the \texttt{clone()} method from the class \texttt{java.lang.Object},
\index{Object@\texttt{Object}}%
all JSBML elements can be deeply copied and are therefore \emph{clone-able}. By
extending the interface \texttt{Serializable},
\index{Serializable@\texttt{Serializable}}%
it is possible to store JSBML
\index{application programming interface!JSBML}%
elements in binary form without explicitly writing them to an SBML file.
\index{SBML!XML file}%
In this way, programs can easily load and save their in-memory objects or send
complex data structures through a network connection without the need of
additional file encoding and subsequent parsing. The third interface,
\texttt{TreeNode}%
\index{TreeNode@\texttt{TreeNode}} 
is actually defined in Java's \texttt{swing}
\index{graphical user interface!swing@\texttt{swing}}%
package.
\texttt{TreeNode} is a type that is independent of any graphical information. It
basically defines recursive methods on hierarchically structured data types,
such as iteration over all of its successors. In this way, all instances of
JSBML's\index{SBase@\texttt{SBase}}%
\texttt{SBase} interface can be directly passed to the \texttt{swing}
\index{graphical user interface!\texttt{swing}}%
class \texttt{JTree}
\index{graphical user interface!\texttt{JTree}}%
and can hence be easily visualized. Listing~\vref{lst:Visualization}
demonstrates in a simple code example how to parse an SBML file
\index{SBML!XML file}%
and to immediately display its content on a \texttt{JFrame}.
\index{graphical user interface!\texttt{JFrame}}%
\ifthenelse{\boolean{includeCodeExample}}{%
  \lstinputlisting[language=Java,float,caption={Parsing and visualizing the
  content of an SBML file},label=lst:Visualization]{%
../posters/2010_ICSB_and_COMBINE/org/sbml/gui/JSBMLvisualizer.java}
  Fig.~\vref{fig:Visualization} shows an example output when applying the
  program to an SBML test model\index{SBML!Test cases}.
  \begin{SCfigure}[][t]
  \includegraphics[width=.35\textwidth]{%
../posters/2010_ICSB_and_COMBINE/JSBMLvisualizerTransparent.png}
  \caption[Tree representation of an SBML file]{A tree representation of the
    content of SBML test model \texttt{case00026}. In JSBML, the hierarchically
    structured \texttt{SBMLDocument} can be traversed recursively because all
    instances of \texttt{SBase} implement the interface \texttt{TreeNode}.}
  \label{fig:Visualization}
  \end{SCfigure}
}{}%
The \texttt{ASTNode} class in JSBML\index{ASTNode@\texttt{ASTNode}} is also
derived from all these three interfaces and can hence be cloned, serialized, and
visualized in the same way.

However, it is important to note that JSBML does not depend on any particular
graphical user interface because no other classes from \texttt{swing} are
initialized when loading the interface
\texttt{TreeNode}\index{TreeNode@\texttt{TreeNode}}.

\subsection{\texttt{AbstractTreeNode}}%
\index{TreeNode!AbstractTreeNode@\texttt{AbstractTreeNode}}

When looking at the SBML specification, one may notice that SBML defines a data
structure in an an entirely tree-based manner. Besides
\texttt{SBase}\index{SBase@\texttt{SBase}}, SBML contains also other kinds of
tree nodes that are hierarchically linked within the \texttt{SBMLDocument}. 
In order to unify the programming interface, JSBML defines abstract data types
as top-level ancestors for its \texttt{SBase} implementation as well as all
other hierarchical elements, such as \texttt{Annotation},
\texttt{ASTNode}\index{ASTNode@\texttt{ASTNode}},
\texttt{Creator}\index{annotation!Creator@\texttt{Creator}},
\texttt{CVTerm}\index{annotation!CVTerm@\texttt{CVTerm}},
\texttt{History}\index{annotation!History@\texttt{History}}, and
\texttt{XMLNode}\index{XML!XMLNode@\texttt{XMLNode}} (for notes in
XHTML\index{XHTML} format).

First, the interface \texttt{TreeNodeWithChangeSupport}%
\index{TreeNodeWithChangeSupport@\texttt{TreeNodeWithChangeSupport}}
defines a \emph{cloneable} and \emph{serializable} version of
\texttt{TreeNode}. In addition, it also provides methods to notify dedicated
\texttt{TreeNodeChangeListener}s%
\index{TreeNodeChangeListener@\texttt{TreeNodeChangeListener}}
about any changes within the data structure.

Its abstract implementation, \texttt{AbstractTreeNode}, does already implement
many of the methods inherited from \texttt{TreeNodeWithChangeSupport} and also
maintains a list of \texttt{TreeNodeChangeListener}s. Furthermore, this class
contains a basic implementation of the methods \texttt{equals} and
\texttt{hashCode}, which both already make use of a recursive call over all
descendants within the hierarchical SBML data structure. Based on this class,
the implementation of all derived data types has become much simpler. The
abstract implementation of \texttt{SBase} is also an instance of
\texttt{AbstractTreeNode}.


\subsection{Characteristic features of \texttt{SBase}s}

The SBML\index{SBML} specifications define the data type
\texttt{SBase}\index{SBase@\texttt{SBase}}\index{SBML!specification} as the
supertype for all other SBML elements. In JSBML, \texttt{SBase} has become an
interface and most elements therefore extend its abstract implementation
\texttt{AbstractSBase}\index{SBase@\texttt{SBase}!\texttt{AbstractSBase}}.

In contrast to libSBML, the Level and Version of such an \texttt{AbstractSBase}
is stored in a special generic object, a \texttt{ValuePair}.
\index{JSBML!ValuePair@\texttt{ValuePair}}%
The class \texttt{ValuePair} takes two values of any type that both implement
the interface \texttt{Comparable}.
\index{Comparable@\texttt{Comparable}}%
Storing the Level/Version combination in such a \texttt{ValuePair}, which itself
implements the \texttt{Comparable} interface, allows users to perform checks for
an expected Level/Version combination of an element more easily, as the example
in Listing~\vref{lst:LevelVersionCheck} demonstrates.
\begin{lstlisting}[language=Java,float=h,caption={Check for a minimal expected Level/Version combination},label={lst:LevelVersionCheck}]
if (mySBase.getLevelAndVersion().compareTo(Integer.valueOf(2),
        Integer.valueOf(2)) < 0) {
  throw new IllegalArgumentException(String.format(
          "Cannot create a %s with Level = %s and Version = &s.",
          mySBase.getElementName(), getLevel(), getVersion()));
}
\end{lstlisting}
The method \texttt{getLevelAndVersion()} in \texttt{AbstractSBase}
\index{SBase@\texttt{SBase}!\texttt{AbstractSBase}}%
delivers an instance of \texttt{ValuePair}
\index{JSBML!ValuePair@\texttt{ValuePair}}%
with the Level and Version combination for the respective element.

Some types derived from \texttt{SBase} contain an identifier, a so-called
\texttt{id}. JSBML gathers all these elements under the common interface
\texttt{NamedSBase}. The class \texttt{AbstractNamedSBase}, which extends
\texttt{AbstractSBase}, implements this interface.
\index{SBase@\texttt{SBase}!\texttt{NamedSBase}}%
\index{SBase@\texttt{SBase}!\texttt{AbstractNamedSBase}}%
The interface \texttt{UniqueNamedSBase} indicates all those elements whose
identifier must be unique within the model, i.e., no other element within the
model may have the same identifier. The identifiers of all instances of
\texttt{NamedSBase} must be unique if these are defined. The Boolean method
\texttt{isIdMandatory()} in \texttt{NamedSBase} indicates if an identifier must
be defined for an element in order to create a valid SBML data structure. The
only two elements with not-unique identifiers are
\texttt{UnitDefinition}s\index{unit!UnitDefinition@\texttt{UnitDefinition}},
whose identifiers exist in a separate namespace, and
\texttt{LocalParameter}s\index{parameter!LocalParameter@\texttt{LocalParameter}},
whose identifiers may shadow the identifiers of global elements.

Many SBML elements represent some quantitative value, which is associated with a
unit. However, the value does not necessarily have to be defined explicitly. In
many cases, it needs to be computed from a formula contained in the instance of
\texttt{SBase} in form of an abstract syntax tree, i.e., \texttt{ASTNode}.
\index{ASTNode@\texttt{ASTNode}}%
Therefore, also the associated unit may not be set explicitly but can be derived
when evaluating the formula. In JSBML, the interface
\texttt{SBaseWithDerivedUnit}
\index{SBase@\texttt{SBase}!\texttt{SBaseWithDerivedUnit}}%
unifies all those elements
that either explicitly or implicitly contain some unit. If these elements can
also be addressed using an identifier, they also implement the interface
\texttt{NamedSBaseWithDerivedUnit}.
\index{SBase@\texttt{SBase}!\texttt{NamedSBaseWithDerivedUnit}}%
Within formulas, i.e., \texttt{ASTNode}s,
references can only be made to instances of \texttt{CallableSBase},
\index{JSBML!CallableSBase@\texttt{CallableSBase}}%
which is a special case of \texttt{NamedSBaseWithDerivedUnit}.
Fig.~\vref{fig:Variable} shows this part of JSBML's type hierarchy in more
detail.

As a special case, these elements may explicitly declare a unit. The interface
\texttt{SBaseWithUnit}
\index{SBase@\texttt{SBase}!\texttt{SBaseWithUnit}}%
serves as the supertype for all those elements that may
be explicitly equipped with a unit. The convenient class
\texttt{AbstractNamedSBaseWithUnit}
\index{SBase@\texttt{SBase}!\texttt{AbstractNamedSBaseWithUnit}}%
\index{SBase@\texttt{SBase}!\texttt{AbstractNamedSBase}}%
extends \texttt{AbstractNamedSBase} and
implements both interfaces \texttt{SBaseWithUnit} and
\index{SBase@\texttt{SBase}!\texttt{SBaseWithUnit}}%
\texttt{NamedSBaseWithDerivedUnit}.
\index{SBase@\texttt{SBase}!\texttt{NamedSBaseWithDerivedUnit}}%
All elements derived from this abstract class may therefore declare a unit and
can be addressed using an unambiguous identifier.

Furthermore, the interface \texttt{Quantity}
\index{JSBML!quantity@\texttt{Quantity}}%
describes an element that is associated with a value and at least a derived
unit. In addition, a \texttt{Quantity} can be addressed
using its unambiguous identifier. JSBML uses the term \texttt{QuantityWithUnit}
for a \texttt{Quantity} that explicitly declares its unit. In contrast to
\texttt{Quantity}, the data type \texttt{QuantityWithUnit}
\index{JSBML!quantityWithUnit@\texttt{QuantityWithUnit}}%
is not an interface, but an abstract class.

If a \texttt{Quantity} provides a Boolean
\index{Boolean}%
switch to decide whether it describes a constant,
\index{constant}%
JSBML represents such a type in the interface \texttt{Variable}.
\index{JSBML!variable@\texttt{Variable}}%
Finally, JSBML refers to \texttt{Variable}s with a defined unit as a
\texttt{Symbol}
\index{JSBML!symbol@\texttt{Symbol}}%
and provides a corresponding abstract class. In this way, the
SBML elements \texttt{Compartment}, \texttt{Parameter}, and \texttt{Species}
\index{compartment!\texttt{Compartment}}%
\index{parameter!\texttt{Parameter}}%
\index{species!\texttt{Species}}%
are special cases of \texttt{Symbol} in JSBML. The specification of SBML Level~3
\index{SBML!Level~3}%
introduces another type of \texttt{Variable}, which does not explicitly declare
its unit: \texttt{SpeciesReference}. On the other hand, a
\texttt{LocalParameter}
\index{parameter!\texttt{LocalParameter}}%
is a \texttt{QuantityWithUnit},
\index{JSBML!quantityWithUnit@\texttt{QuantityWithUnit}}%
but not a \texttt{Variable}, because it is always constant.
\index{constant}%


\subsection{The \texttt{MathContainer} interface}

This interface gathers all those elements that may contain mathematical
expressions encoded in abstract syntax trees (instances of
\texttt{ASTNode}\index{ASTNode@\texttt{ASTNode}}).
The abstract class \texttt{AbstractMathContainer}
\index{JSBML!MathContainer@\texttt{MathContainer}}%
serves as actual superclass
for the majority of the derived types.
Figs.~\vrefrange{fig:MathContainer}{fig:MathContainerHierarchy} give a better
overview of how this data structure is intended to function.


\subsection{The \texttt{Assignment} interface}

JSBML
\index{JSBML!assignment@\texttt{Assignment}}%
unifies all those elements that may
change the value of some \emph{variable} in SBML\index{SBML} under the interface
\texttt{Assignment}. This interface uses the term \emph{variable}
for the element whose value is to be changed
depending on some mathematical expression that is also present in the
\texttt{Assignment} (because \texttt{Assignment} extends the interface
\texttt{MathContainer}).
\index{JSBML!MathContainer@\texttt{MathContainer}}%
Therefore,
an \texttt{Assignment} contains methods such as
\texttt{set}-/\texttt{getVariable(Variable v)} and also \texttt{isSetVariable()}
as well as \texttt{unsetVariable()}. In addition to that, JSBML also provides
the methods \texttt{set}-/\texttt{getSymbol(String symbol)} in the
\texttt{InitialAssignment}
\index{InitialAssignment@\texttt{InitialAssignment}}%
class to make sure that switching from libSBML
to JSBML is quite smoothly.
However, the preferred way in JSBML
\index{JSBML!variable@\texttt{Variable}}%
is to apply the methods \texttt{setVariable} either with \texttt{String}
\index{String@\texttt{String}!identifier}%
or \texttt{Variable} instances as arguments.
Fig.~\vref{fig:MathContainerHierarchy} displays the type hierarchy of the
\texttt{Assignment} interface in more detail.



\section{Differences in the abstract programming interface}

JSBML strives to attain an almost complete compatibility to libSBML. However,
the differences in the programming languages \texttt{C++}
\index{C++@\texttt{C++}}%
and Java\texttrademark{} lead to the necessity of introducing some differences.
In some cases, a direct ``translation" from \texttt{C++} and \texttt{C} code to
\index{C@\texttt{C}}%
Java would not be very elegant. JSBML wants to provide a Java API,
\index{application programming interface!Java}%
whose classes and methods are structured, named, and behave like classes and
methods in other Java libraries. In this section, we will discuss the most
important differences in the APIs of JSBML
\index{application programming interface!JSBML}%
and libSBML.
\index{application programming interface!libSBML}%


\subsection{Abstract syntax trees}

Both libraries define a class \texttt{ASTNode}\index{ASTNode@\texttt{ASTNode}}
for in-memory manipulation and evaluation of abstract syntax trees that represent
mathematical formulas and equations. These can either be parsed from a representation in \texttt{C}
language-like \texttt{String}s\index{String@\texttt{String}!formula}, or from a MathML\index{MathML} representation. The JSBML\index{ASTNode@\texttt{ASTNode}}
\texttt{ASTNode} provides various methods to transform these trees to other
formats, for instance, \LaTeX{}
\index{LaTeX@\LaTeX} \texttt{String}s. In JSBML, several static
methods allow easy creation of new syntax trees, for instance, the following
code
\begin{lstlisting}[language=Java,numbers=none]
ASTNode myNode = ASTNode.plus(myLeftAstNode, myRightASTNode);
\end{lstlisting}
creates a new instance of \texttt{ASTNode} which represents the sum of the two
other \texttt{ASTNode}s. In this way, even complex trees can be easily
manipulated.

In SBML, abstract syntax trees may refer to the following elements:
\texttt{Parameter}s, \texttt{LocalParameter}s, \texttt{FunctionDefinition}s,
\texttt{Reaction}s, \texttt{Compartment}s, \texttt{Species}, and, since Level~3,
also \texttt{SpeciesReference}s. JSBML gathers all these elements under the
common interface \texttt{CallableSBase},
\index{JSBML!CallableSBase@\texttt{CallableSBase}}%
\index{SBase@\texttt{SBase}!CallableSBase@\texttt{CallableSBase}}%
which extends the interface \texttt{NamedSBaseWithDerivedUnit}.
\index{JSBML!NamedSBaseWithDerivedUnit@\texttt{NamedSBaseWithDerivedUnit}}%
\index{SBase@\texttt{SBase}!%
NamedSBaseWithDerivedUnit@\texttt{NamedSBaseWithDerivedUnit}}%
In this way, JSBML ensures that only identifiers of those elements can be set in
instances of \texttt{ASTNode}.
\index{ASTNode@\texttt{ASTNode}}%
JSBML provides a set of convenient constructors and methods to work with
instances of \texttt{CallableSBase},
\index{JSBML!CallableSBase@\texttt{CallableSBase}}%
\index{SBase@\texttt{SBase}!CallableSBase@\texttt{CallableSBase}}%
of which we here give a short overview.
\begin{lstlisting}[language=Java,numbers=none,float=h,captionpos=t,
title={Getter and setter:}]
public void setVariable(CallableSBase variable) { ... }

public CallableSBase getVariable() { ... }
\end{lstlisting}
The set method allows users to change the type of an \texttt{ASTNode} to
\texttt{ASTNode.Type.NAME}
\index{ASTNode@\texttt{ASTNode}!ASTNode.Type@\texttt{ASTNode.Type}}%
and to directly set the name to the identifier of the
given \texttt{CallableSBase}.
\index{JSBML!CallableSBase@\texttt{CallableSBase}}%
\index{SBase@\texttt{SBase}!CallableSBase@\texttt{CallableSBase}}%
The \texttt{get} method directly looks for the corresponding element in the
\texttt{Model}\index{model!Model@\texttt{Model}}%
and returns this element. If no such element can be found or the type of the
\texttt{ASTNode} is something different from \texttt{ASTNode.Type.NAME}, an
\index{ASTNode@\texttt{ASTNode}!ASTNode.Type@\texttt{ASTNode.Type}}%
\index{ASTNode@\texttt{ASTNode}}%
exception will be thrown.

\begin{lstlisting}[language=Java,numbers=none,float=h,captionpos=t,
title={Some examples for convenient manipulation methods, of which some are static:}]
public static ASTNode frac(MathContainer container,
      CallableSBase numerator, CallableSBase denominator) {...}

public static ASTNode pow(MathContainer container,
      CallableSBase basis, CallableSBase exponent) { ... }

public ASTNode plus(CallableSBase nsb) { ... }
\end{lstlisting}
Methods like these above facilitate creating or manipulating complex abstract
syntax trees. Several static methods are available that directly create small
trees from given elements in memory, whereas some methods such as the
\texttt{plus} method changes the structure of existing syntax trees.

\begin{lstlisting}[language=Java,numbers=none,float=h,captionpos=t,
title={Some examples for convenient constructors:}]
public ASTNode(CallableSBase nsb) { ... }

public ASTNode(CallableSBase nsb, MathContainer parent) { ... }
\end{lstlisting}
With these constructors, dedicated single nodes can be created whose type
(from the enumeration \texttt{ASTNode.Type}) will be \texttt{NAME}
\index{ASTNode@\texttt{ASTNode}!ASTNode.Type@\texttt{ASTNode.Type}}%
and whose name will be set to the identifier of the given
\texttt{CallableSBase}.
\index{JSBML!CallableSBase@\texttt{CallableSBase}}%
\index{SBase@\texttt{SBase}!CallableSBase@\texttt{CallableSBase}}%


\subsection{The \texttt{ASTNodeCompiler} class}

This interface allows users to create customized interpreters for the
content of mathematical equations encoded in abstract syntax trees. It
is directly and recursively called from the \texttt{ASTNode} class and returns
an \texttt{ASTNodeValue}
\index{ASTNode@\texttt{ASTNode}!\texttt{ASTNodeValue}}%
\index{ASTNode@\texttt{ASTNode}!\texttt{ASTNodeCompiler}}%
object, which wraps the possible evaluation results of the interpretation.
JSBML\index{ASTNode@\texttt{ASTNode}} already provides several implementations of this
interface, for instance, \texttt{ASTNode} objects can be directly translated to
\texttt{C} language-like \texttt{String}s\index{String@\texttt{String}!formula},
\LaTeX,\index{LaTeX@\LaTeX} or MathML\index{MathML} for further processing.
Furthermore, the class \texttt{UnitsCompiler},
\index{unit!UnitsCompiler@\texttt{\texttt{UnitsCompiler}}}%
which JSBML uses to derive the unit of an abstract syntax tree, also implements
this interface.

\subsection{Cloning when adding child nodes to instances of \texttt{SBase}}

When adding elements such as a \texttt{Species}
\index{species!\texttt{Species}}%
to a \texttt{Model}\index{model!\texttt{Model}}, libSBML\index{cloning} will
clone the object and add the clone to the \texttt{Model}. In contrast,
JSBML\index{cloning} does
not automatically perform cloning. The advantage is that modifications on the
object belonging to the original pointer will also propagate to the element
added to the \texttt{Model}. Furthermore, this is more efficient with respect to
the run time and also more intuitive for Java programmers. If cloning is
necessary, users should call the \texttt{clone()} method manually. Since all
instances of \texttt{SBase}\index{SBase@\texttt{SBase}} and also
\texttt{Annotation}\index{annotation},
\texttt{ASTNode}\index{ASTNode@\texttt{ASTNode}},
\texttt{CVTerm}\index{annotation!\texttt{CVTerm}}, and
\texttt{History}\index{annotation!\texttt{History}} extend
\texttt{AbstractTreeNode}\index{AbstractTreeNode@\texttt{AbstractTreeNode}},
which in turn implements the interface \texttt{Cloneable}\index{cloning} (see
Fig.~\vref{fig:TypeHierarchy}), all these elements can be naturally cloned.
However, when cloning an object in JSBML\index{cloning}, such as an
\texttt{AbstractNamedSBase},
\index{SBase@\texttt{SBase}!\texttt{AbstractNamedSBase}}
% all children of this element will recursively be cloned before adding them to
% the new element. This is necessary, because the data structures specified in
% SBML \index{SBML!hierarchical structure}
define a tree, in which each element has exactly one parental node.

\subsection{Deprecation}

The intention of JSBML\index{JSBML!deprecation} is to provide a Java library
that supports the latest specifications of SBML\index{SBML}.
\index{SBML!specification}%
\index{deprecation}%
But we also want to support earlier specifications. So JSBML provides methods
and classes to cover elements and properties from earlier SBML specifications as
well, but these are often marked as being deprecated to avoid creating models
that refer to these elements. Furthermore, JSBML contains many methods just for
compatibility with libSBML, for instance, a method such as \texttt{getNumXyz()}
is not considered to be very Java-like, but very common
\texttt{C++}\index{C++@\texttt{C++}} programming style. Usually, Java
programmers would expect the method being called \texttt{getXyzCount()}
instead. In cases like this, JSBML provides alternative methods and marks these
methods that originate from libSBML as deprecated.


\subsection{Compartments}

In SBML Level 3
\index{SBML!Level~3}%
\citep{Hucka2010a}, the domain of the \texttt{spatialDimensions} attribute in
\texttt{Compartment}s was changed from $\lbrace 0, 1, 2, 3\rbrace$, which can be
represented with a \texttt{short} value in Java, to a value in $\mathbb{R}$,
i.e., a \texttt{double} value. For this reason, the method
\texttt{getSpatialDimensions()} in JSBML
always returns a \texttt{double} value. For consistency with libSBML, the
\texttt{Compartment} class in JSBML also provides the redundant method
\texttt{getSpatialDimensionsAsDouble()} that returns the identical value, but
that is marked as a deprecated method.
\index{compartment}%
\index{compartment!\texttt{getSpatialDimensions()}}%
\index{compartment!\texttt{getSpatialDimensionsAsDouble()}}%


\subsection{Exceptions}

In case of an error, JSBML
\index{exception}%
throws often an exception while libSBML\index{exception!error codes} methods
return some error codes instead. This behavior helps programmers and users to
avoid creating invalid SBML data structures already when dealing with these in
memory. Furthermore, exception handling is very well implemented in Java and it
is therefore a better programming style in this language. Methods can already
declare that these may potentially throw exceptions. In this way, programmers
can be aware of potential sources of problems already at the time of writing the
source code. Examples are the \texttt{ParseException}
\index{exception!\texttt{ParseException}}%
that may be thrown if a given formula cannot be parsed properly into an
\texttt{ASTNode}
\index{ASTNode@\texttt{ASTNode}}%
data structure, or \texttt{InvalidArgumentException}s
\index{exception!\texttt{InvalidArgumentException}}%
if inappropriate values are passed to methods. For instance,
\begin{itemize}
 \item An object representing a constant\index{constant} such as a
 \texttt{Parameter} whose \texttt{constant} attribute has been set to
\texttt{true} cannot be used as the \texttt{Variable} element in an
\texttt{Assignment}.
\index{JSBML!assignment@\texttt{Assignment}}%
\index{JSBML!variable@\texttt{Variable}}%
\index{parameter!\texttt{Parameter}}%
\index{parameter!\texttt{constant}}%
 \item An instance of \texttt{Priority}\index{event!\texttt{Priority}} can only
 be assigned to an \texttt{Event}s\index{event!\texttt{Event}} if its
 \texttt{level}\index{SBML!Level~3} attribute has at least been set to
 three.\index{SBase@\texttt{SBase}!\texttt{AbstractNamedSBase}}
 \item Another example is the \texttt{InvalidArgumentException} that
 is thrown when trying to set an invalid identifier \texttt{String} for an
 instance of \texttt{AbstractNamedSBase}.
 \item JSBML keeps track of all identifiers within a model. For each namespace
 it contains a separate set of identifiers within the
 \texttt{Model}\index{Model@\texttt{Model}}. It is therefore not possible to
 assign duplicate identifiers in case of elements that implement the interface
 \texttt{UniqueNamedSBase}\index{UniqueNamedSBase@\texttt{UniqueNamedSBase}}.
 For \texttt{UnitDefinition}s\index{Unit!UnitDefinition@\texttt{UnitDefinition}}
 and \texttt{LocalParameter}s separate sets are maintained. Since local
 parameters are only visible within the
 \texttt{KineticLaw}\index{KineticLaw@\texttt{KineticLaw}} that contain these,
 JSBML will only prohibit having more than one local parameter within the same
 list that has the identical identifier. All these sets are updated upon any
 changes within the model. When adding an element with an already existing
 identifier for its namespace, or changing some identifier to a value that is
 already defined within this namespace, JSBML will throw an exception.
 \item Meta identifiers must be unique through the entire SBML file. To ensure
 that no duplicate meta identifiers are created, JSBML keeps a set of all meta
 identifiers on the level of the
 \texttt{SBMLDocument}\index{SBML!SBMLDocument@\texttt{SBMLDocument}}, which is
 updated upon any change of elements within the data structure. In this way, it
 is not possible to set the meta identifier of some element to an already
 existing value or to add nodes to the SBML tree that contain a meta identifier
 defined somewhere else within the tree. In both cases, JSBML will throw an
 exception. Since meta identifiers can be generated in a fully automatic way
 (method \texttt{nextMetaId()} on \texttt{SBMLDocument}), users of JSBML should
 not care about these identifiers at all. JSBML will automatically create meta
 identifiers where missing upon writing an SBML file.
\end{itemize}
Hence, you have to be aware of potential exceptions and errors when using JSBML,
\index{exception}%
on the other hand this will prevent you from doing obvious mistakes. The class
\texttt{SBMLReader} in JSBML catches those errors and exceptions. With the help
of the logging utility, JSBML notifies users about syntactical problems in SBML
files. JSBML follows the rule that illegal or invalid properties are not set.


\subsection{Model history}

In earlier versions of SBML\index{SBML}, only the model itself could be
associated with a history, i.e., a description about the person(s) who build
this model, including names, e-mail addresses, modification and creation dates.
Nowadays, it has become possible to annotate each individual construct of an
SBML model with such a history. This is reflected by naming the corresponding
object \texttt{History}\index{annotation!\texttt{History}}
in JSBML\index{annotation!\texttt{ModelHistory}}, whereas it is still called
\texttt{ModelHistory} in libSBML\index{annotation!\texttt{ModelHistory}}. Hence,
all instances of \texttt{SBase}\index{SBase@\texttt{SBase}} in JSBML
\index{annotation!\texttt{ModelHistory}} contain methods to access and
manipulate its \texttt{History}. Furthermore, you will not find the classes
\texttt{ModelCreator} and \texttt{ModelCreatorList} because
JSBML\index{annotation!\texttt{ModelCreator}}
gathers its \texttt{Creator} objects
in a generic \texttt{List<Creator>} in the
\texttt{History}\index{annotation!\texttt{History}}.


\subsection{Replacement of the interface \texttt{libSBMLConstants} by Java \texttt{enum}s}

You will not find an implementation corresponding to the interface
\texttt{libSBMLConstants} in JSBML. The reason is that the JSBML team decided to
encode constants
\index{constant!\texttt{enum}}%
using the Java construct \texttt{enum}. For instance, all the fields starting
with the prefix \texttt{AST\_TYPE\_*}
\index{ASTNode@\texttt{ASTNode}!\texttt{AST\_TYPE\_*}}%
have a corresponding field in the \texttt{ASTNode} class itself. There you can
find the \texttt{enum} \texttt{Type}.
\index{ASTNode@\texttt{ASTNode}!\texttt{ASTNode.Type}}%
Instead of typing \texttt{libSBMLConstants.AST\_TYPE\_PLUS}, you would therefore
type \texttt{ASTNode.Type.PLUS}.

The same holds true for \texttt{Unit.Kind.*} corresponding to the
\texttt{libSBMLConstants.UNIT\_KIND\_*}
\index{unit!UNIT\_KIND\_*@\texttt{UNIT\_KIND\_*}}%
fields.

\subsection{The classes \texttt{libSBML} and \texttt{JSBML}}

There is no class \texttt{libSBML} because this library is called JSBML.
\index{libSBML!libSBML@\texttt{libSBML}}%
You can therefore only find a class \texttt{JSBML}.
\index{JSBML!JSBML@\texttt{JSBML}}%
This class provides some similar methods as the \texttt{libSBML} class in
libSBML, such as \texttt{getJSBMLDottedVersion()}
\index{JSBML!version}%
to obtain the current version of the JSBML library, which is 0.8.* at the time of
writing this document. However, many other methods that you might expect
to find there, if you are used to libSBML, are located in the actual classes
that are related with the function. For instance, the method to convert between
a \texttt{String}
\index{String@\texttt{String}!unit}%
\index{unit!String@\texttt{String}}%
and a corresponding \texttt{Unit.Kind}
\index{unit!Unit.Kind@\texttt{Unit.Kind}}%
can be done by using the method
\begin{lstlisting}[language=Java,numbers=none]
Unit.Kind myKind = Unit.Kind.valueOf(myString);
\end{lstlisting}
In a similar way, the \texttt{ASTNode}\index{ASTNode@\texttt{ASTNode}} class
provides a method to parse \texttt{C}-like infix formula
\texttt{String}s\index{String@\texttt{String}!formula} according to the
specification of SBML Level~1\index{SBML!Level~1} \citep{Hucka2003} into an
abstract syntax tree\index{ASTNode@\texttt{ASTNode}}. Therefore, in contrast to
the \texttt{libSBML} class, the class \texttt{JSBML}\index{JSBML!JSBML@\texttt{JSBML}}
contains only a few methods.


\subsection{Various types of \texttt{ListOf*} classes}

% We have the method get(String) on the ListOf and libsbml does not have it on
% the main ListOf class, only on subclasses where it is possible to do it.

In JSBML, there is not a specific
\texttt{ListOf*}\index{ListOf*@\texttt{ListOf*}} class for each type of
\texttt{SBase}\index{SBase@\texttt{SBase}} elements. We used a generic
implementation \texttt{ListOf<?~extends SBase>} that allows us to use the same
class for each of the different \texttt{ListOf*} classes defined in libSBML
while keeping a type-safe class. We defined several methods that use the
\texttt{Filter} interface to search or filter a \texttt{ListOf} object. For
example, to query an instance of \texttt{ListOf} in JSBML for names or
identifiers or both, you can apply the following filter:
\begin{lstlisting}[language=Java,numbers=none]
NamedSBase nsb = myList.firstHit(new NameFilter(identifier));
\end{lstlisting}
This will give you the first element in the list with the given identifier.
Various filters are already implemented, but you can easily add your
customized filter. To this end, you only have to implement the \texttt{Filter}
\index{ListOf*@\texttt{ListOf*}!\texttt{Filter}}%
interface in \texttt{org.sbml.jsbml.util.filters}.
\index{ListOf*@\texttt{ListOf*}!\texttt{Filter}}%
There you can also find an \texttt{OrFilter} and an \texttt{AndFilter}, which
take as arguments multiple other filters. With the \texttt{SBOFilter} you can
query for certain SBO  annotations \citep{Novere2006,Novere2006b}
\index{annotation!SBO}%
in your list, whereas the \texttt{CVTermFilter} helps you to identify
\texttt{SBase}
\index{SBase@\texttt{SBase}}%
instances with a desired MIRIAM (Minimal Information Required In the Annotation
of Models) annotation\index{annotation} \citep{Novere2005}. For instances of
\texttt{ListOf<Species>} you can apply the \texttt{BoundaryConditionFilter} to
look for those species\index{species!boundary condition} that operate on the
boundary of the reaction system.


\subsection{Units and unit definitions}
\subsubsection{The exponent attribute of units}

Since SBML Level~3\index{SBML!Level~3} \citep{Hucka2010a} the data type of the
exponent attribute in the \texttt{Unit} class has been changed from \texttt{int}
to \texttt{double} values. JSBML
\index{unit!Unit@\texttt{Unit}}%
\index{unit!getExponent()@\texttt{getExponent()}}%
\index{unit!getExponentAsDouble()@\texttt{getExponentAsDouble()}}%
reflects this in the method \texttt{getExponent()} by returning \texttt{double}
values only. For a better compatibility with libSBML, whose corresponding method
still returns \texttt{int} values, JSBML also provides the method
\texttt{getExponentAsDouble()}. This method returns the value from the
\texttt{getExponent()} method and is therefore absolutely redundant.


\subsubsection{Predefined unit definitions}

A model in JSBML
\index{unit!predefined units}%
always also contains all predefined units in the model
if there are any, i.e., for models encoded with SBML versions before Level~3.
\index{SBML!Level~3}%
These can be accessed from an instance of \texttt{Model} by calling the method
\texttt{getPredefinedUnit(String unit)}.

MIRIAM annotations\index{annotation!MIRIAM} \citep{Novere2005} have become an integral part of SBML models
since Level~2 Version~2\index{SBML!Level~2 Version~2}. Recently, the Unit
Ontology\index{Ontology}\footnote{\url{http://www.obofoundry.org/cgi-bin/detail.cgi?id=unit}}
\index{annotation!unit ontology}%
(UO) has been included in the set of supported ontology and online resources of
MIRIAM. Since all the predefined units in SBML have corresponding entries in the
UO, JSBML
\index{unit!MIRIAM annotation}%
automatically equips those predefined units with the correct MIRIAM
URI in form of a controlled vocabulary term (\texttt{CVTerm}) if the
Level/Version combination of the model supports MIRIAM annotations.

Note that the \texttt{enum} \texttt{Unit.Kind}
\index{unit!Unit.Kind@\texttt{Unit.Kind}}%
also provides methods to directly obtain the entry from the UO that corresponds
to a certain unit kind and also contains methods to generate MIRIAM URIs
accordingly. In this way, JSBML facilitates the annotation of user-defined
units and unit definitions with MIRIAM-compliant\index{annotation!MIRIAM}
information.

\subsubsection{Access to the units of an element}

In JSBML, all SBML elements, that can be associated with some unit, implement
the interface \texttt{SBaseWithUnit}.
\index{SBase@\texttt{SBase}!\texttt{SBaseWithUnit}}%
This interface provides methods to directly
access an object representing their unit. Currently, the following elements
implement this interface:
\begin{itemize}
 \item \texttt{AbstractNamedSBaseWithUnit}
 \item \texttt{ExplicitRule}\index{rule!\texttt{ExplicitRule}}
 \item \texttt{KineticLaw}
 \index{KineticLaw@\texttt{KineticLaw}}
\end{itemize}
Fig.~\vref{fig:TypeHierarchy} provides a better overview about the relationships
between all the classes explained here. Note that
\texttt{AbstractNamedSBaseWithUnit} serves as the abstract superclass for
\texttt{Event}\index{event} and \texttt{QuantityWithUnit}.
\index{JSBML!quantityWithUnit@\texttt{QuantityWithUnit}}%
In the class \texttt{Event}, all methods
to deal with units are deprecated because the \texttt{timeUnits} attribute
was removed in SBML Level~2 Version~2\index{SBML!Level~2}. The same holds true
for instances of
\texttt{ExplicitRule}\index{rule!\texttt{ExplicitRule}}
and \texttt{KineticLaw},\index{KineticLaw@\texttt{KineticLaw}}
which both can only be explicitly populated with units in SBML
Level~1\index{SBML!Level~1} for \texttt{ExplicitRule} and before SBML in
Level~2, Version~3\index{SBML!Level~2} for \texttt{KineticLaw}. In contrast,
\texttt{QuantityWithUnit}
\index{JSBML!quantityWithUnit@\texttt{QuantityWithUnit}}%
serves as the abstract superclass for \texttt{LocalParameter}
\index{parameter!\texttt{LocalParameter}}%
and \texttt{Symbol},
\index{JSBML!symbol@\texttt{Symbol}}%
which is then again the super type of \texttt{Compartment}, \texttt{Species},
and (global) \texttt{Parameter}.
\index{compartment!\texttt{Compartment}}%
\index{species!\texttt{Species}}%
\index{parameter!\texttt{Parameter}}%

With \texttt{SBaseWithUnit}
\index{SBase@\texttt{SBase}!\texttt{SBaseWithUnit}}%
being a subtype of \texttt{SBaseWithDerivedUnit}
\index{SBase@\texttt{SBase}!\texttt{SBaseWithDerivedUnit}}%
users can access the units of such an element in two different ways:
\begin{description}
 \item[\texttt{getUnit()}] This method returns the
 \texttt{String}\index{String@\texttt{String}!unit}
 \index{unit!String@\texttt{String}}%
 of the unit kind or the unit definition in the model
 \index{model}%
 that has been directly set by the user
 during the life time of the element. If nothing has been declared, an empty
 \texttt{String} will be delivered.
 \item[\texttt{getDerivedUnit()}] This method gives either the same result as
 \index{unit!derived unit}%
 \texttt{getUnit()} if some unit has been declared explicitly, or it returns the
 predefined unit of the element for the given SBML Level/Version combination.
 Only if neither a user-defined nor a predefined unit is available, this method
 returns an empty \texttt{String}\index{String@\texttt{String}!empty}.
\end{description}
Both methods have corresponding methods to directly obtain an instance of
\texttt{UnitDefinition}
\index{unit!UnitDefinition@\texttt{UnitDefinition}}%
for convenience.

However, care must be taken when obtaining an instance of
\texttt{UnitDefinition}
\index{unit!UnitDefinition@\texttt{UnitDefinition}}%
from one of the classes implementing \texttt{SBaseWithUnit}
\index{SBase@\texttt{SBase}!\texttt{SBaseWithUnit}}%
because it might happen that the model\index{model} containing this
\texttt{SBaseWithUnit}
\index{SBase@\texttt{SBase}!\texttt{SBaseWithUnit}}%
does actually not contain the required instance of \texttt{UnitDefinition} and
the method returns a \texttt{UnitDefinition} that has just been created for
convenience from the information provided by the class. It might therefore be
useful to either check if the \texttt{Model}\index{model!\texttt{Model}}
contains this \texttt{UnitDefinition}
\index{unit!UnitDefinition@\texttt{UnitDefinition}}%
or to add it to the \texttt{Model}\index{model!\texttt{Model}}.

In case of \texttt{KineticLaw}
\index{KineticLaw@\texttt{KineticLaw}}%
it is even more difficult, because
SBML Level~1\index{SBML!Level~1} allows to separately set the substance unit and the time unit of
the element. To unify the API\index{application programming interface!JSBML}, we decided to also provide methods that allow
the user to simply pass one \texttt{UnitDefinition}
\index{unit!UnitDefinition@\texttt{UnitDefinition}}%
or its identifier to
\texttt{KineticLaw}.
\index{KineticLaw@\texttt{KineticLaw}}%
These methods then try to guess if a substance unit or time
unit is given. Furthermore, it is possible to pass a \texttt{UnitDefinition}
representing a variant of substance per time directly. In this case, the
\texttt{KineticLaw}
\index{KineticLaw@\texttt{KineticLaw}}%
will memorize a direct link to this \texttt{UnitDefinition}
in the model\index{model} and also try to save separate links to the time unit and the
substance unit. However, this may cause a problem if the containing
\texttt{Model}\index{model!\texttt{Model}} does not contain separate \texttt{UnitDefinition}s for both
entries.

Generally, this approach provides a more general way to access and to manipulate
units of SBML elements.

\section{Additional features of JSBML}

The JSBML library also provides some features that cannot be found in libSBML.
This section briefly introduces its most important additional capabilities.

\subsection{Change listeners}

JSBML introduces the possibility to listen to change events in the life of an
SBML document. To benefit from this advantage, simply let your class implement
the interface
\texttt{TreeNodeChangeListener}\index{event!\texttt{TreeNodeChangeListener}}
and add it to the list of listeners in your instance of
\texttt{SBMLDocument}\index{SBML!\texttt{SBMLDocument}}. You only have to
implement three methods
\begin{description}
 \item[\texttt{nodeAdded(TreeNode node)}] This method notifies the listener
 that the given \texttt{TreeNode}\index{TreeNode@\texttt{TreeNode}} has just
 been added to the \texttt{SBMLDocument}. When this method is called, the given
 node is already fully linked to the \texttt{SBMLDocument}, i.e., it has a valid
 parent that in turn points to the given node.
 \item[\texttt{nodeRemoved(TreeNode node)}] The \texttt{TreeNode} instance
 passed to this method is no longer part of the \texttt{SBMLDocument} as it has
 just been removed. This means that the entire \texttt{SBMLDocument} does not
 contain any pointers to this node anymore, but the node itself still contains a
 pointer to its former parent. In this way, it is possible to recognize where
 in the tree this node was located and even to revert the deletion of the node.
 \item[\texttt{propertyChange(PropertyChangeEvent node)}] This method provides
 detailed information about some value change within the \texttt{SBMLDocument}.
 The object passed to this method is an
 \texttt{TreeNodeChangeEvent}\index{event!\texttt{TreeNodeChangeEvent}}, which
 provides information about the
 \texttt{TreeNode}\index{TreeNode@\texttt{TreeNode}} that has been changed, its
 property whose value has been changed (this is a
 \texttt{String}\index{String@\texttt{String}} representation of the name of
 the property), along with the previous value and the new value.
\end{description}
With the help of these methods, you can keep track of what your
\texttt{SBMLDocument}\index{SBML!\texttt{SBMLDocument}} does at any time.
Furthermore, one could consider to make use of this functionality in a graphical
user interface\index{graphical user interface}, where the user should be asked
if he or she really wants to delete some element or to approve changes before
making these persistent. Another idea of using this, would be to write log
files\index{logging!log file} of the model\index{model} building process
automatically. To this end, JSBML already provides the implementation
\texttt{SimpleTreeNodeChangeListener},
\index{event!\texttt{SimpleTreeNodeChangeListener}}%
which notifies a logger about each change.

Note that the class
\texttt{TreeNodeChangeEvent}\index{event!\texttt{TreeNodeChangeEvent}} extends
the class \texttt{java.beans.Property\-Change\-Event},%
\index{event!PropertyChangeEvent@\texttt{PropertyChangeEvent}}
which is derived from 
\texttt{java.util.EventObject}\index{event!EventObject@\texttt{EventObject}}.
It should also be pointed out that the interface
\texttt{TreeNodeChangeListener}%
\index{event!TreeNodeChangeListener@\texttt{TreeNodeChangeListener}}
extends the interface \texttt{java.beans.Pro\-perty\-Change\-Listener}
\index{event!PropertyChangeListener@\texttt{PropertyChangeListener}}
which in turn extends the interface \texttt{EventListener}%
\index{event!EventListener@\texttt{EventListener}}
in the package \texttt{java.util}. In this way, the event and listener data
structures fit into the common Java\texttrademark{} API (Application
Programming Interface)\index{application programming interface!Java} and allow
users also to make use of, e.g.,
\texttt{EventHandler}s\index{event!\texttt{EventHandler}} to deal with changes
in a model\index{model}. 

Since in JSBML all major data objects implement the interface \texttt{TreeNode},
these listeners are notified about any kind of change in any implementing data
structure. The interface \texttt{TreeNodeWithChangeSupport} extends Java's
standard \texttt{TreeNode} interface by adding methods that maintain a list of
\texttt{TreeNodeChangeListeners} and notify these whenever some property changes
or nodes are added/deleted from the tree. In this way, the
\texttt{TreeNodeChangeListener}s do not only keep track of changes in instances
of \texttt{SBase}. This means that changes inside of, e.g.,
\texttt{CVTerm}\index{annotation!\texttt{CVTerm}} or
\texttt{History}\index{annotation!\texttt{History}} may can also be traced with
this implementation.


\subsection{Determination of the variable in \texttt{AlgebraicRule}s}

The class \texttt{OverdeterminationValidator}
\index{JSBML!OverdeterminationValidator@\texttt{OverdeterminationValidator}}%
in JSBML provides methods to
determine if a model\index{model!over determination}
is over determined. This is done using the algorithm of \citet{Hopcroft1973}.
While doing that, it also determines the variable element for each
\texttt{AlgebraicRule}\index{rule!\texttt{AlgebraicRule}} if
possible. In JSBML, \texttt{AlgebraicRule} even provides a method
\texttt{getDerivedVariable()} to directly obtain a pointer to its free variable.


\subsection{\texttt{find*} methods}

JSBML provides users with several \texttt{find*} methods
\index{JSBML!\texttt{find*} methods}%
on a \texttt{Model}
\index{model!\texttt{Model}}%
to quickly query for elements, based on their identifier or name. Developers can
search for various instances of \texttt{SBase} (for instance,
\texttt{CallableSBase},
\index{SBase@\texttt{SBase}!\texttt{CallableSBase}}%
\texttt{NamedSBase},
\index{SBase@\texttt{SBase}!\texttt{NamedSBase}}%
\texttt{NamedSBaseWithDerivedUnit})
\index{SBase@\texttt{SBase}!\texttt{NamedSBaseWithDerivedUnit}}%
or use the methods \texttt{findLocalParameters}, \texttt{findQuantity},
\texttt{findQuantityWithUnit}, \texttt{findQuantityWithUnit},
\texttt{findSymbol}, and \texttt{findVariable} to search for the corresponding
element in the model. This enables a quick and easy way to work with SBML
models, without having to iterate through the elements of a \texttt{Model} again
and again.

\subsection{Utility classes provided by JSBML}

JSBML also provides some convenient additional utility classes. We here discuss
some of these classes in more detail, which are all gathered in
the package \texttt{org.sbml.jsbml.util}. There you can also find a growing
number of additional helpful classes.


\subsubsection{Pre-implemented mathematical functions and constants}

The class \texttt{org.sbml.jsbml.util.Maths}
\index{JSBML!Maths@\texttt{Maths}}%
contains several \texttt{static} methods for mathematics operations not provided
by the standard Java class \texttt{java.lang.Math}. Most of these methods are
basic operations, for instance, \texttt{cot(double x)} or \texttt{ln(double x)}.
The class \texttt{Maths} also provides some less commonly used methods,
such as \texttt{csc(double x)} or \texttt{sech(double x)} as well as
\texttt{double} constants representing Avogadro's number ($6.02214199 \cdot
10^{23}\;\mathrm{mol}^{-1}$) and the universal gas constant
$R = 8.314472\;\mathrm{J}\cdot\mathrm{mol}^{-1}\cdot\mathrm{K}^{-1}$. In this
way, the functions and constants implemented in class \texttt{Maths} complement
standard Java with methods and numbers required by the SBML specifications
\citep{Hucka2003, Hucka2008, Hucka2010a}.

\subsubsection{Some tools for \texttt{String} manipulation}

The class \texttt{StringTools}
\index{String@\texttt{String}!tools}%
provides several methods for convenient \texttt{String} manipulation. These
methods are particularly useful when parsing or displaying \texttt{double}
numbers in a \texttt{Locale}\hyp{}dependent way. To this end, this class
predefined a selection of useful number formats. It can also wrap
\texttt{String} elements into HTML code, mask non-ASCII characters using
corresponding HTML codes, efficiently concatenate \texttt{String}s, or deliver
the operating system\hyp{}dependent new line character.


\subsection{Logging functionality}
\index{logging}%

% \paragraph{}
JSBML makes use of the logger provided by the log4j
project\footnote{\url{http://logging.apache.org/log4j/}}.
Log4j allows us to use six levels
of logging (\texttt{TRACE}, \texttt{DEBUG},
\texttt{INFO}, \texttt{WARN}, \texttt{ERROR}, and \texttt{FATAL}) but inside
JSBML we mainly use \texttt{ERROR}, \texttt{WARN}, and \texttt{DEBUG}. The
default configuration of log4j used in JSBML can be found in the folder
\texttt{resources} with the name \texttt{log4j.properties}.
In this file, you will found some documentation of which JSBML classes do some
logging and at which levels.
 
If you do not change anything, all the log messages, starting at the info level 
(meaning info, warn, error and fatal), will be printed on the console.
Some of these messages might be useful to warn the end-users that something
goes wrong.

% TODO : should we changed the default to print in the jsbml.log file ???

If you want to modify the default log4j behavior, you will need to create a
customized log4j configuration file. The best way of doing this, according to
the log4j
manual\footnote{\url{http://logging.apache.org/log4j/1.2/manual.html}}, is to
define and use the \texttt{log4j.configuration} environment variable to point to
the log4j configuration file to use. One way of doing this is to add the
following option to your \texttt{java} command:
\begin{lstlisting}[language=bash,numbers=none,captionpos=t]
-Dlog4j.configuration=/home/user/myLog4j.properties
\end{lstlisting}

\subsubsection{Some example configurations}
\ifthenelse{\boolean{includeCodeExample}}{}{\index{logging!configuration}}%

% \paragraph{}
Listing~\vref{lst:log4j1} gives a short overview about how to
customize the configuration file to log all the changes that happen to the SBML
elements by putting the threshold of all the loggers in the
\texttt{org.sbml.jsbml.util} package to \texttt{DEBUG}. The class
\texttt{SimpleTreeNodeChangeListener}
\index{event!SimpleTreeNodeChangeListener@\texttt{SimpleTreeNodeChangeListener}}%
will then output the old value and the new value whenever a setter methods is
used on the SBML elements.
\begin{lstlisting}[language=bash,%numbers=none,
caption={A simple log4j example.},label=lst:log4j1]
# All logging output sent to the console
log4j.rootCategory=INFO, console

#
# Console Display
#
log4j.appender.console=org.apache.log4j.ConsoleAppender
log4j.appender.console.layout=org.apache.log4j.PatternLayout

# Pattern to output the caller's file name and line number.
log4j.appender.console.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} - %5p (%F:%L) - %m%n

# Log the messages from the SimpleTreeNodeChangeListener at the DEBUG Level
# Allow to see all the changes that happened to the SBML elements
log4j.logger.org.sbml.jsbml.util=DEBUG
\end{lstlisting}

When you enable the debug level
\index{logging}%
on some loggers, the output can became quite large and the help of some log
viewers software\footnote{\url{http://en.wikipedia.org/wiki/Log4j\#Log_Viewers}}
can become handy to filter the log output.

% \paragraph{}
If you are deploying your application in an application server such as Tomcat,
you could define an appender that would send some messages by e-mail.
Listing~\vref{lst:log4j2} gives an example of that, were any messages from the
error level
\index{logging}%
are send by mail. All the messages are also written to a rolling log
file.
\begin{lstlisting}[language=bash,%numbers=none,
caption={SMTPAppender log4j example.}, label=lst:log4j2]
# Logging is sent to a file and by email from the info level.
log4j.rootLogger=info, file, mail

#
# email appender definition
# it will send by email all messages from the error level.
#
log4j.appender.mail=org.apache.log4j.net.SMTPAppender
#defines how often emails are send
log4j.appender.mail.BufferSize=1
log4j.appender.mail.SMTPHost="smtp.myservername.xx"
log4j.appender.mail.From=fromemail@myservername.xx
log4j.appender.mail.To=toemail@myservername.xx
log4j.appender.mail.Subject=Log ...
log4j.appender.mail.threshold=error
log4j.appender.mail.layout=org.apache.log4j.PatternLayout
log4j.appender.mail.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n

### file appender
log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.maxFileSize=100KB
log4j.appender.file.maxBackupIndex=5
log4j.appender.file.File=test.log
log4j.appender.file.threshold=info
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{ISO8601} %5p %c{1}:%L - %m%n
\end{lstlisting}

Using XML instead of a properties file to define the log4j configuration, you
can even send some log levels\index{logging} to one appender and others to an
other appender, using the \texttt{LevelRange} filter. In this way, you could
output the \texttt{DEBUG} messages only to a separate file.


\subsection{JSBML modules}

JSBML modules extend the functionality of JSBML and are provided as separate
libraries (JAR files). With the help of the current JSBML modules, JSBML can be
used as a communication layer \index{JSBML!as communication layer} between your
application and libSBML \citep{Bornstein2008} or between your program and the
program known as CellDesigner \citep{Funahashi2003}. Furthermore, a
compatibility module
\index{libSBML!compatibility module}%
will try to provide the same package structure and API as in the libSBML Java
bindings. In this section, we will give small code examples of how to make use
of these modules.

\subsubsection{How to use libSBML for parsing SBML into JSBML data structures?}

The capabilities of the SBML validator\index{SBML!validator} constitute the
major strength of libSBML \citep{Bornstein2008} in comparison to JSBML, which
does not yet contain a stand-alone validator for SBML, but makes use of the
online validation provided at \url{http://sbml.org}. Furthermore, if the
platform-dependency of libSBML does not hamper your application, or you want to
slowly switch from libSBML to JSBML, you may want to be able to still read and
write SBML models using libSBML. To this end, the JSBML module
\texttt{libSBMLio} provides the classes \texttt{LibSBMLReader}
\index{JSBML!LibSBMLReader@\texttt{LibSBMLReader}}%
and \texttt{LibSBMLWriter}.
\index{JSBML!LibSBMLWriter@\texttt{LibSBMLWriter}}%
Listing~\vref{lst:LibSBMLio} gives a small example of how to use the
\texttt{LibSBMLReader}. For this example to run, please make sure to have
libSBML installed correctly on your system. The current version of the
libSBML/JSBML interface at the time of writing this document requires libSBML
version 4.2.0.
\index{libSBML!version}%
To this end, you may have to set environment variables, e.g., the
\texttt{LD\_LIBRARY\_PATH}
\index{libSBML!LD\_LIBRARY\_PATH@\texttt{LD\_LIBRARY\_PATH}}%
under Linux operating system\index{operating system}, appropriately. For
details, see the documentation of
libSBML\footnote{\url{http://sbml.org/Software/libSBML}}.
\begin{lstlisting}[language=Java,float,caption={A simple example for
converting libSBML data structures into JSBML data objects},label=lst:LibSBMLio]
  /** @param args the path to a valid SBML file. */
  public static void main(String[] args) {
    try {
      // Load libSBML:
      System.loadLibrary("sbmlj");
      // Extra check to be sure we have access to libSBML:
      Class.forName("org.sbml.libsbml.libsbml");

      // Read SBML file using libSBML and convert it to JSBML:
      LibSBMLReader reader = new LibSBMLReader();
      SBMLDocument doc = reader.convertSBMLDocument(args[0]);

      // Run some application:
      new JSBMLvisualizer(doc);

    } catch (Throwable e) {
      e.printStackTrace();
    }
  }
\end{lstlisting}
Writing SBML works similarly. Example~\vref{lst:LibSBMLio} will display the
content of an SBML file in a \texttt{JTree}, similar as shown in
Fig.~\vref{fig:Visualization}.

\subsubsection{How to turn a JSBML-based application into a CellDesigner plugin?}

Once an application has been implemented based on JSBML, it can easily be
accessed from CellDesigner's plugin menu \citep{Funahashi2003}. To this end,
it is necessary to extend two classes that are defined in CellDesigner's plugin
API (Application Programming Interface).%
\index{application programming interface!CellDesigner} 
The Listings~\vrefrange{lst:PluginAction} {lst:Plugin} show a very simple example
of how to pass CellDesigner plugin\index{CellDesigner!plugin}
model\index{model!CellDesigner} data structures to the translator in JSBML,
which creates then a JSBML \texttt{Model}\index{model!\texttt{Model}} data
structure.\index{CellDesigner!\texttt{PluginAction}}%
\lstinputlisting[language=Java,float,caption={A simple implementation of
CellDesigner's abstract class \texttt{PluginAction}},
label=lst:PluginAction]{%
../SimpleCellDesignerPlugin/org/sbml/jsbml/cdplugin/SimpleCellDesignerPluginAction.java}
% \lstinputlisting[language=Java,float,caption={SimpleCellDesignerPlugin},
% label=lst:Plugin]{SimpleCellDesignerPlugin/org/sbml/jsbml/cdplugin/SimpleCellDesignerPlugin.java}
\begin{lstlisting}[language=Java,float,caption={A simple example for a
CellDesigner plugin using JSBML as a communication layer},label=lst:Plugin]
package org.sbml.jsbml.cdplugin;

import javax.swing.*;
import jp.sbi.celldesigner.plugin.*;
import org.sbml.jsbml.*;
import org.sbml.jsbml.gui.*;

/** A very simple implementation of a plugin for CellDesigner. */
public class SimpleCellDesignerPlugin extends CellDesignerPlugin {

  public static final String ACTION = "Display full model tree";
  public static final String APPLICATION_NAME = "Simple Plugin";

  /** Creates a new CellDesigner plugin with an entry in the menu bar. */
  public SimpleCellDesignerPlugin() {
    super();
    try {
      System.out.printf("\n\nLoading %s\n\n", APPLICATION_NAME);
      SimpleCellDesignerPluginAction action = new SimpleCellDesignerPluginAction(this);
      PluginMenu menu = new PluginMenu(APPLICATION_NAME);
      PluginMenuItem menuItem = new PluginMenuItem(ACTION, action);
      menu.add(menuItem);
      addCellDesignerPluginMenu(menu);
    } catch (Exception exc) {
      exc.printStackTrace();
    }
  }

  /** This method is to be called by our CellDesignerPluginAction. */
  public void startPlugin() {
    PluginSBMLReader reader = new PluginSBMLReader(getSelectedModel(), SBO
        .getDefaultPossibleEnzymes());
    Model model = reader.getModel();
    SBMLDocument doc = new SBMLDocument(model.getLevel(), model
        .getVersion());
    doc.setModel(model);
    new JSBMLvisualizer(doc);
  }

  // Include also methods from superclass, not needed in this example.
  public void addPluginMenu() { }
  public void modelClosed(PluginSBase psb) { }
  public void modelOpened(PluginSBase psb) { }
  public void modelSelectChanged(PluginSBase psb) { }
  public void SBaseAdded(PluginSBase psb) { }
  public void SBaseChanged(PluginSBase psb) { }
  public void SBaseDeleted(PluginSBase psb) { }
}
\end{lstlisting}
The examples described by Listings~\vrefrange{lst:PluginAction}{lst:Plugin}
create a plugin for CellDesigner, which displays the SBML data structure
in a tree, like the example in Fig.~\vref{fig:Visualization}. This example only
shows how to translate a plugin data structure
from CellDesigner into a corresponding JSBML data structure. With the help of
the class \texttt{PluginSBMLWriter} it is possible to notify CellDesigner about
changes in the model data structure. Note that Listing~\vref{lst:Plugin} is only
completed by implementing the methods from the superclass,
\texttt{CellDesignerPlugin}. In this example it is sufficient to leave the
implementation of several methods empty.


\subsubsection{\texttt{libSBMLcompat}, the JSBML compatibility module for
libSBML}

The compatibility module of JSBML will use the same package structure as the
libSBML java bindings and provides identically named classes and API. Using the
module, it will be possible to switch an existing application from libSBML to
JSBML or the other way around without changing any code.

This module is in development and will be available with the version 1.0 of
JSBML.
\index{libSBML!compatibility module}%

\subsubsection{\texttt{android}, a compatibility module for Android systems}
\index{Android}
This module is intended to provide all those classes from the Java\texttrademark{}
standard distribution that are required for JSBML, but might be missing on
Android systems. Since this module is currently under development, it can be
expected to be available with the release of JSBML version 1.0.
